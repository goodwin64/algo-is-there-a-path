{"version":3,"sources":["utils.ts","App.js","serviceWorker.js","index.js"],"names":["getCellsNeighboursNetwork","cells","config","cellToNeighbourhood","i","currentCell","getXYindex","boardSizeY","boardSizeX","currentIndexY","currentIndexX","getNeighbour","t","r","b","l","myNetwork","id","Set","filter","Boolean","neighbour","isConnected","map","cell","createMyNetwork","forEach","mergeSets","member","length","s1","s2","elem","add","flatIndex","rowsCount","cellsCount","Math","floor","indexY","indexX","direction","deltaX","deltaY","cell1","cell2","value","boardSizePx","styles","cellSizePx","Array","fill","index","round","random","App","React","useState","startPointId","setStartPointId","endPointId","setEndPointId","startPointNeighbours","console","log","handleCellClick","e","cellId","target","dataset","style","width","height","_","chunk","row","className","key","classnames","filled","startPoint","endPoint","isInNeighbour","has","data-cell-id","onClick","id1","id2","startNeigbourNetwork","isTherePath","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ec0809e6.chunk.js","sourcesContent":["import { IAppConfig, ICell, IAllCellsNetwork, IDirection, IOneCellNetwork } from './Interfaces';\n\nexport default function isTherePath(\n  cells: ICell[],\n  id1: number,\n  id2: number,\n  config: IAppConfig,\n): boolean {\n  const cellToNeighbourhood = getCellsNeighboursNetwork(cells, config);\n  const startNeigbourNetwork = cellToNeighbourhood[id1];\n  const endPoint = cells[id2];\n  return startNeigbourNetwork.has(endPoint.id);\n}\n\nexport function getCellsNeighboursNetwork(\n  cells: ICell[],\n  config: IAppConfig,\n) {\n  const cellToNeighbourhood: IAllCellsNetwork = {};\n\n  for (let i = 0; i < cells.length; i++) {\n    const currentCell = cells[i];\n    const [currentIndexY, currentIndexX] = getXYindex(i, config.boardSizeY, config.boardSizeX);\n    const [t, r, b, l] = [\n      getNeighbour(cells, currentIndexY, currentIndexX, 'top', config.boardSizeY, config.boardSizeX),\n      getNeighbour(cells, currentIndexY, currentIndexX, 'right', config.boardSizeY, config.boardSizeX),\n      getNeighbour(cells, currentIndexY, currentIndexX, 'bottom', config.boardSizeY, config.boardSizeX),\n      getNeighbour(cells, currentIndexY, currentIndexX, 'left', config.boardSizeY, config.boardSizeX),\n    ];\n    const myNetwork = createMyNetwork(cells, currentCell, config);\n    if (!(i in cellToNeighbourhood)) {\n      cellToNeighbourhood[i] = myNetwork;\n    }\n\n    [t, r, b, l].forEach(neighbour => {\n      if (!neighbour || !isConnected(currentCell, neighbour) || !(neighbour.id in cellToNeighbourhood)) {\n        return;\n      }\n      mergeSets(myNetwork, cellToNeighbourhood[neighbour.id]);\n    });\n\n    [t, r, b, l].forEach(neighbour => {\n      if (!neighbour || !isConnected(currentCell, neighbour) || !(neighbour.id in cellToNeighbourhood)) {\n        return;\n      }\n      cellToNeighbourhood[neighbour.id].forEach((member) => {\n        if (cellToNeighbourhood[member]) {\n          mergeSets(cellToNeighbourhood[member], myNetwork);\n        }\n      })\n    });\n  }\n  return cellToNeighbourhood;\n}\n\nexport function mergeSets<T>(s1: Set<T>, s2: Set<T>) {\n  s2.forEach(elem => s1.add(elem));\n}\n\nexport function createMyNetwork(\n  cells: ICell[],\n  currentCell: ICell,\n  config: IAppConfig,\n): IOneCellNetwork {\n  const [currentIndexY, currentIndexX] = getXYindex(currentCell.id, config.boardSizeY, config.boardSizeX);\n\n  const [t, r, b, l] = [\n    getNeighbour(cells, currentIndexY, currentIndexX, 'top', config.boardSizeY, config.boardSizeX),\n    getNeighbour(cells, currentIndexY, currentIndexX, 'right', config.boardSizeY, config.boardSizeX),\n    getNeighbour(cells, currentIndexY, currentIndexX, 'bottom', config.boardSizeY, config.boardSizeX),\n    getNeighbour(cells, currentIndexY, currentIndexX, 'left', config.boardSizeY, config.boardSizeX),\n  ];\n\n  // @ts-ignore\n  return new Set(\n    [t, r, b, l, currentCell]\n      .filter(Boolean)\n      .filter(neighbour => isConnected(neighbour, currentCell))\n      // @ts-ignore\n      .map(cell => cell.id),\n  );\n}\n\nexport function getXYindex(\n  flatIndex: number,\n  rowsCount: number,\n  cellsCount: number,\n): [number, number] {\n  return [\n    Math.floor(flatIndex / rowsCount),\n    flatIndex % cellsCount,\n  ];\n}\n\nexport function getNeighbour(\n  cells: ICell[],\n  indexY: number,\n  indexX: number,\n  direction: IDirection,\n  boardSizeY: number,\n  boardSizeX: number,\n): ICell | undefined {\n  let deltaX = 0;\n  let deltaY = 0;\n\n  if (direction === 'left') {\n    if (indexX === 0) {\n      return undefined;\n    }\n    deltaX = -1;\n  } else if (direction === 'right') {\n    if (indexX === boardSizeX - 1) {\n      return undefined;\n    }\n    deltaX = 1;\n  } else if (direction === 'top') deltaY = -1;\n  else if (direction === 'bottom') deltaY = 1;\n\n  const rowIndex = indexY + deltaY;\n  const cellIndex = indexX + deltaX;\n\n  return cells[(rowIndex) * boardSizeY + (cellIndex)];\n}\n\nfunction isConnected(\n  cell1?: ICell,\n  cell2?: ICell,\n): Boolean {\n  return Boolean(cell1 && cell2 && cell1.value === cell2.value);\n}\n","import React from 'react';\nimport classnames from 'classnames';\nimport _ from 'lodash';\n\nimport './App.css';\nimport isTherePath, { getCellsNeighboursNetwork } from './utils.ts';\n\nexport const config = {\n  boardSizeX: 25,\n  boardSizeY: 25,\n  boardSizePx: 720,\n};\nexport const styles = {\n  cellSizePx: config.boardSizePx / config.boardSizeX,\n};\n\nconst cells = Array(config.boardSizeX * config.boardSizeY)\n  .fill(null)\n  .map((value, index) => ({\n    value: Math.round(Math.random()),\n    id: index,\n  }))\n;\n\n// const cells = [{\"value\":1,\"id\":0},{\"value\":0,\"id\":1},{\"value\":0,\"id\":2},{\"value\":1,\"id\":3},{\"value\":1,\"id\":4},{\"value\":1,\"id\":5},{\"value\":1,\"id\":6},{\"value\":0,\"id\":7},{\"value\":0,\"id\":8},{\"value\":1,\"id\":9},{\"value\":0,\"id\":10},{\"value\":0,\"id\":11},{\"value\":0,\"id\":12},{\"value\":1,\"id\":13},{\"value\":1,\"id\":14},{\"value\":1,\"id\":15},{\"value\":0,\"id\":16},{\"value\":1,\"id\":17},{\"value\":1,\"id\":18},{\"value\":1,\"id\":19},{\"value\":0,\"id\":20},{\"value\":1,\"id\":21},{\"value\":1,\"id\":22},{\"value\":1,\"id\":23},{\"value\":1,\"id\":24},{\"value\":1,\"id\":25},{\"value\":1,\"id\":26},{\"value\":1,\"id\":27},{\"value\":1,\"id\":28},{\"value\":1,\"id\":29},{\"value\":1,\"id\":30},{\"value\":0,\"id\":31},{\"value\":0,\"id\":32},{\"value\":1,\"id\":33},{\"value\":0,\"id\":34},{\"value\":1,\"id\":35},{\"value\":0,\"id\":36},{\"value\":0,\"id\":37},{\"value\":0,\"id\":38},{\"value\":1,\"id\":39},{\"value\":0,\"id\":40},{\"value\":0,\"id\":41},{\"value\":1,\"id\":42},{\"value\":1,\"id\":43},{\"value\":1,\"id\":44},{\"value\":1,\"id\":45},{\"value\":0,\"id\":46},{\"value\":0,\"id\":47},{\"value\":1,\"id\":48},{\"value\":0,\"id\":49},{\"value\":1,\"id\":50},{\"value\":0,\"id\":51},{\"value\":0,\"id\":52},{\"value\":0,\"id\":53},{\"value\":1,\"id\":54},{\"value\":0,\"id\":55},{\"value\":0,\"id\":56},{\"value\":0,\"id\":57},{\"value\":0,\"id\":58},{\"value\":0,\"id\":59},{\"value\":0,\"id\":60},{\"value\":0,\"id\":61},{\"value\":1,\"id\":62},{\"value\":0,\"id\":63},{\"value\":1,\"id\":64},{\"value\":1,\"id\":65},{\"value\":1,\"id\":66},{\"value\":1,\"id\":67},{\"value\":1,\"id\":68},{\"value\":1,\"id\":69},{\"value\":1,\"id\":70},{\"value\":0,\"id\":71},{\"value\":1,\"id\":72},{\"value\":1,\"id\":73},{\"value\":1,\"id\":74},{\"value\":0,\"id\":75},{\"value\":0,\"id\":76},{\"value\":0,\"id\":77},{\"value\":1,\"id\":78},{\"value\":0,\"id\":79},{\"value\":0,\"id\":80},{\"value\":1,\"id\":81},{\"value\":1,\"id\":82},{\"value\":0,\"id\":83},{\"value\":0,\"id\":84},{\"value\":0,\"id\":85},{\"value\":0,\"id\":86},{\"value\":0,\"id\":87},{\"value\":1,\"id\":88},{\"value\":1,\"id\":89},{\"value\":1,\"id\":90},{\"value\":1,\"id\":91},{\"value\":0,\"id\":92},{\"value\":0,\"id\":93},{\"value\":1,\"id\":94},{\"value\":1,\"id\":95},{\"value\":0,\"id\":96},{\"value\":0,\"id\":97},{\"value\":1,\"id\":98},{\"value\":0,\"id\":99}]\n\nconst cellToNeighbourhood = getCellsNeighboursNetwork(cells, config);\n\nfunction App() {\n  const [startPointId, setStartPointId] = React.useState(-1);\n  const [endPointId, setEndPointId] = React.useState(-1);\n\n  const startPointNeighbours = cellToNeighbourhood[startPointId] || new Set();\n  console.log('startPointNeighbours', startPointNeighbours);\n\n  const handleCellClick = (e) => {\n    const cellId = +e.target.dataset.cellId;\n    if (cellId === startPointId) {\n      setStartPointId(-1);\n    } else if (cellId === endPointId) {\n      setEndPointId(-1);\n    } else if (startPointId === -1) {\n      setStartPointId(cellId);\n    } else {\n      setEndPointId(cellId);\n    }\n  };\n\n  return (\n    <div>\n      <div\n        id=\"board\"\n        style={{ width: config.boardSizePx, height: config.boardSizePx }}\n      >\n        {\n          _.chunk(cells, config.boardSizeY).map(row => (\n            <div className=\"row\" key={row[0].id}>\n              {\n                row.map((cell) => (\n                  <div\n                    key={cell.id}\n                    className={classnames('cell', {\n                      filled: cell.value,\n                      startPoint: startPointId === cell.id,\n                      endPoint: endPointId === cell.id,\n                      isInNeighbour: startPointNeighbours.has(cell),\n                    })}\n                    data-cell-id={cell.id}\n                    onClick={handleCellClick}\n                    style={{ width: styles.cellSizePx, height: styles.cellSizePx }}\n                  >\n                    {startPointId === cell.id || endPointId === cell.id || cell.id}\n                  </div>\n                ))\n              }\n            </div>\n          ))\n        }\n      </div>\n      <h1 className=\"result\">\n        {\n          startPointId === -1 || endPointId === -1\n            ? 'select start & end points'\n            : isTherePath(cells, startPointId, endPointId, config) ? 'path exists' : 'no path'\n        }\n      </h1>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}